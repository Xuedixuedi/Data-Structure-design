<h2 align="center">Project documentation</h2>
<h1 align="center">Data structure course design</h1>
<h2 align="right">â€”â€”Family tree management system</h2>






















<p align="right">
  Author nameï¼š<U>Xuedi Liu</U><br>
  Numberï¼š<U>1752985</U><br>
  instructorï¼š<U>Ying Zhang</U><br>
  College/Majorï¼š<U>School of Software Engineering/Software Engineering</U><br>
</p>



<div STYLE="page-break-after:always;">
</div>

<div STYLE="page-break-after:always;">
</div>

[TOC]



<div STYLE="page-break-after:always;">
</div>

## 1. Analysis

### 1.1 Project background analysis

Genealogy is a special book genre in the form of a spectrum that records a family's hereditary reproduction and important missions based on blood relationship. Genealogy is a unique cultural heritage of China. It is one of the three major Chinese literatures (national history, local history, genealogy). It is a valuable humanistic material. It is an in-depth study of history, folklore, demography, sociology and economics. It has its unique and irreplaceable features. This project performs a simple simulation of genealogy management to view the personal information of ancestors and descendants, insert family members, and delete family members.

### 1.2 Project function requirements

The essence of this project is to complete the establishment, search, insert, modify, delete and other functions of family members. You can first define the family member data structure, and then use each function as a member function to complete the operation of the data. Function to verify the function of each function and get the running result.

<div STYLE="page-break-after:always;">
</div>

## 2. Design

### 2.1 Data structure design

In the family tree, an ancestor will breed multiple children, and his children will continue to breed, generating multiple children and two generations. Among them, the father and offspring of each generation directly form a one-to-many relationship, but one offspring cannot correspond to multiple parents. This non-linear and non-ringing relationship is a typical tree structure. We use a tree data structure to store the family relationships in the family tree.

Considering that a parent may correspond to multiple children, the number of children cannot be completely determined at this time, which will cause the structure of the tree to be diversified and it will be difficult to standardize it in a specific form, so that we are traversing , Insert, delete and other operations will encounter a lot of coding trouble.

We consider the use of the rule of "left eldest son, right brother" for a multi-tree, normalize the multi-tree to a binary tree, and construct an equivalent tree of a family tree: Left-child right-sibling binary tree. 

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/N-ary_to_binary.svg/500px-N-ary_to_binary.svg.png)

This kind of data structure has such advantages:

1. This representation saves up memory by limiting the maximum number of references required per node to two.
2. It is easier to code.

But it also has disadvantages as follow:

Basic operations like searching/insertion/deletion tend to take a longer time because in order to find the appropriate position we would have to traverse through all the siblings of the node to be searched/inserted/deleted (in the worst case).

### 2.2 Class structure design

In computer science, a binary tree is a tree structure with up to two subtrees per node. Subtrees are usually called "left subtree" and "right subtree". Binary trees are often used to implement binary search trees and binary heaps. A binary tree with a depth of k and 2 ^ k-1 nodes is called a full binary tree.

As a non-linear chain storage structure that satisfies the one-to-many correspondence relationship, the implementation of the binary tree can use arrays and linked lists. Among them, since the implementation of the family tree management in this question involves many insertions and deletions, we need to perform more frequent insertions, deletions, and changes to the nodes and subtrees of the binary tree. If an array is used, the management of the array will It becomes very cumbersome, and despite the savings in space complexity, it is still very cumbersome to code. So we finally chose the structure of the chain tree to store the family tree.

The data structure of a tree is generally similar to the composition of a linked list, and is composed of a node class and a tree class that stores nodes and relationships between nodes.



### 2.3 Member and operational design

#### 1. Node

```C++
template<typename T>
class BinNode {
private:
    T _data;//æ•°æ®
    int _height;//é«˜åº¦
public:
    BinNode *parent, *lChild, *rChild;//çˆ¶äº² å·¦å­©å­ï¼Œå³å­©å­
    BinNode() : parent(nullptr), lChild(nullptr), rChild(nullptr), _height(0) {}

    BinNode(T data, BinNode<T> *p = nullptr, BinNode<T> *lc = nullptr,
            BinNode<T> *rc = nullptr, int h = 0) :
            _data(data), parent(p), lChild(lc), rChild(rc), _height(h) {}

    int size();//ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„åä»£è§„æ¨¡
    T data() { return this->_data; }//è¿”å›è¯¥èŠ‚ç‚¹çš„æ•°æ®
    void setData(T data1) { this->_data = data1; }

    BinNode *insertAsLC(T t);

    BinNode *insertAsRC(T t);
};
```

**Core functionï¼š**

Insert a new node as left/right child:

```c++
template<typename T>
BinNode<T> *BinNode<T>::insertAsLC(T t) {
    return this->lChild = new BinNode(t, this);
}

template<typename T>
BinNode<T> *BinNode<T>::insertAsRC(T t) {
    return this->rChild = new BinNode(t, this);
}
```

#### 2. BinTree

**Private membersï¼š**

```c++
private:
    int _size;//æ ‘çš„è§„æ¨¡
    BinNode<T> *_root;//æ ¹èŠ‚ç‚¹
```

**Public operationï¼š**

```c++
public:
    BinTree() : _size(0), _root(nullptr) {}

    ~BinTree() { if (0 < _size) remove(_root); }

    int size() { return this->_size; }

    bool empty() { return !_size; }

    BinNode<T> *root() { return _root; }

    BinNode<T> *insertAsRoot(T t);//ä½œä¸ºè·ŸèŠ‚ç‚¹æ’å…¥ï¼ˆåˆå§‹åŒ–
    BinNode<T> *insertAsLC(BinNode<T> *x, T t);//ä½œä¸ºxèŠ‚ç‚¹çš„å·¦å­©å­æ’å…¥ï¼Œdata=t
    BinNode<T> *insertAsRC(BinNode<T> *x, T t);//ä½œä¸ºxèŠ‚ç‚¹çš„å³å­©å­æ’å…¥ï¼Œdata=t
    BinNode<T> *search(T t);//æŸ¥æ‰¾å†…å®¹ä¸ºtçš„æŸä¸ªå…ƒç´ (ä½¿ç”¨å‰åºéå†ï¼‰

    std::queue<BinNode<T> *> showChild(BinNode<T> *x);//è¾“å‡ºè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­ä¸€ä»£,å¹¶ç”¨é˜Ÿåˆ—å­˜å‚¨æ‰€æœ‰å­ä¸€ä»£
    void remove(BinNode<T> *p);//è§£æ•£dataä¸ºtçš„å­ğŸŒ²åŠä»–è‡ªèº«
```

**Core functionï¼š**

Insert subtree as root nodeï¼š

```c++
template<typename T>
BinNode<T> *BinTree<T>::insertAsRoot(T t) {
    this->_root = new BinNode<T>(t);
    _size++;
}
```

Insert node as left/right childï¼š

```c++
template<typename T>
BinNode<T> *BinTree<T>::insertAsLC(BinNode<T> *x, T t) {
    x->insertAsLC(t);
    _size++;
}

template<typename T>
BinNode<T> *BinTree<T>::insertAsRC(BinNode<T> *x, T t) {
    x->insertAsRC(t);
    _size++;
}
```

Find the position of the node in the binary treeï¼š

```c++
template<typename T>
BinNode<T> *BinTree<T>::search(T t) {
    std::stack<BinNode<T> *> s;
    auto p = this->_root;
    s.push(p);
    while (!s.empty() || p != nullptr) {
        if (p->data() == t) {
            return p;
        } else {
            s.push(p);
            p = p->lChild;
            while (p == nullptr) {
                p = s.top();
                p = p->rChild;
                s.pop();
            }
        }

    }
}
```

Show sub-generation of this nodeï¼š

```C++
template<typename T>
std::queue<BinNode<T> *> BinTree<T>::showChild(BinNode<T> *x) {
    std::queue<BinNode<T> *> child;
    if (x->lChild != nullptr) {
        std::cout << x->lChild->data() << "  ";
        child.push(x->lChild);
    } else {
        std::cout << "ä»–æ²¡æœ‰å­ä»£" << std::endl;
    }
    while (x->rChild != nullptr) {
        child.push(x->rChild);
        std::cout << x->rChild->data() << "  ";
        x = x->rChild;
    }
    std::cout << std::endl;
    return child;
}
```

Delete the node and the child treeï¼š

```C++
template<typename T>
void BinTree<T>::remove(BinNode<T> *p) {
    if (p == nullptr) {
        return;
    }
    if (p->lChild != nullptr) {
        remove(p->lChild);
    }
    if (p->rChild != nullptr) {
        remove(p->rChild);
    }
    delete p;
}
```

<div STYLE="page-break-after:always;">
</div>

## 3. Realization

### 3.1 Init a family tree

#### 1. Init core code

```c++
BinTree<string> *initFamily() {
    cout << "é¦–å…ˆå»ºç«‹ä¸€ä¸ªå®¶è°±!" << endl;
    cout << "è¯·è¾“å…¥ç¥–å…ˆçš„å§“åï¼š";
    string ancestor;
    cin >> ancestor;
    auto tree = new BinTree<string>;
    tree->insertAsRoot(ancestor);
    cout << "è¿™ä¸ªå®¶æ—çš„ç¥–å…ˆæ˜¯ï¼š" << tree->root()->data() << endl;
    return tree;
}
```

#### 3. Init result demonstration

![image-20191205210706449](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205210706449.png)

<div STYLE="page-break-after:always;">
</div>

### 3.2 Complete family tree

#### 1. Complete flowchart and description

![æœªå‘½åæ–‡ä»¶(9)](/Users/xuedixuedi/Downloads/Misc/æœªå‘½åæ–‡ä»¶(9).png)

#### 2. Complete function core code

```c++
void completeFamily(BinTree<string> *tree) {
    cout << "è¯·è¾“å…¥è¦å»ºç«‹å®¶åº­çš„äººçš„å§“åï¼š";
    string name;
    cin >> name;
    auto p = tree->search(name);
    while (p == nullptr) {
        cout << "æ‚¨è¾“å…¥çš„å§“åä¸åœ¨å®¶è°±ä¸­,è¯·æ‚¨é‡æ–°è¾“å…¥ï¼š";
        cin >> name;
        p = tree->search(name);
    }
    cout << "è¯·è¾“å…¥" << name << "çš„å„¿å¥³æ•°ï¼š";
    int num;
    cin >> num;
    auto p0 = p;//è®°å½•è¯¥èŠ‚ç‚¹ä½ç½®
    while (num <= 0) {
        cout << "æ‚¨è¾“å…¥çš„æ•°å­—æœ‰è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥" << endl;
        cin >> num;
    }
    cout << "è¯·ä¾æ¬¡è¾“å…¥" << name << "çš„å„¿å¥³å§“å: ";
    string child;
    cin >> child;
    p->insertAsLC(child);
    num--;
    while (num--) {
        cin >> child;
        p->insertAsRC(child);
        p = p->rChild;
    }
    cout << name << "çš„ç¬¬ä¸€ä»£å­å­™æ˜¯ï¼š ";
    tree->showChild(p0);
}
```

#### 3. Complete operation diagram

![image-20191205212905832](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205212905832.png)

<div STYLE="page-break-after:always;">
</div>

### 3.3 Implementation of dissolution of local families

#### 1. Dissolution operation flowchart

![æœªå‘½åæ–‡ä»¶(10)](/Users/xuedixuedi/Downloads/Misc/æœªå‘½åæ–‡ä»¶(10).png)

#### 2. Core code of dissolution operation

```c++
void disbandLocalFamily(BinTree<string> *tree) {
    cout << "è¯·è¾“å…¥è¦è§£æ•£å®¶åº­çš„äººçš„å§“åï¼š ";
    string name;
    cin >> name;
    while(tree->search(name) == nullptr){
        cout << "æ‚¨è¾“å…¥çš„å§“åä¸åœ¨å®¶è°±ä¸­,è¯·æ‚¨é‡æ–°è¾“å…¥ï¼š";
        cin >> name;
    }
    cout << "è¦è§£æ•£å®¶åº­çš„äººæ˜¯ï¼š" << name << endl;
    cout << name << "çš„ç¬¬ä¸€ä»£å­å­™æ˜¯: ";
    auto p = tree->search(name);
    tree->showChild(p);
    tree->remove(p);
}
```

#### 3. Evaluation diagram

![image-20191205223152471](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205223152471.png)



<div STYLE="page-break-after:always;">
</div>

### 3.4 Implementation of changing the name of a family member

#### 1. Rename operation flowchart

![æœªå‘½åæ–‡ä»¶(10)](/Users/xuedixuedi/Downloads/Misc/æœªå‘½åæ–‡ä»¶(10).png)

#### 2. Rename operation core code

```c++
void changeName(BinTree<string> *tree) {
    cout << "è¯·è¾“å…¥è¦æ›´æ”¹å§“åçš„äººç›®å‰çš„å§“åï¼š";
    string formerName, name;
    cin >> formerName;
    auto p = tree->search(formerName);
    while(p == nullptr){
        cout << "æ‚¨è¾“å…¥çš„å§“åä¸åœ¨å®¶è°±ä¸­,è¯·æ‚¨é‡æ–°è¾“å…¥ï¼š";
        cin >> formerName;
        p = tree->search(formerName);
    }
    cout << "è¯·è¾“å…¥æ›´æ”¹åçš„å§“åï¼š ";
    cin >> name;
    p->setData(name);
    cout << formerName << "å·²æ›´åä¸º" << name << endl;
}
```

#### 3. Rename operation diagram

![image-20191205224751791](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205224751791.png)

<div STYLE="page-break-after:always;">
</div>

## 4. Test

### 4.1 Boundary test

#### 1. Family tree becomes an empty tree after deletion

**Experimental resultï¼š**

All child nodes are successfully deleted.

![image-20191205233556526](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205233556526.png)

<div STYLE="page-break-after:always;">
</div>

### 4.3 Error test

#### 1. Wrong name entered when creating family tree

**Experimental resultï¼š**

![image-20191205234349470](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205234349470.png)

#### 2. The number of descendants entered is not positive when creating a family tree

**Experimental resultï¼š**

![image-20191205234508821](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205234508821.png)

#### 3. The name entered when the family was dissolved does not exist

**Experimental resultï¼š**

![image-20191205234637147](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205234637147.png)

####  4. Dismissed family member has no children

**Experimental resultï¼š**

![image-20191205234725759](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205234725759.png)

#### 5. The member who changed the name is not in the family tree

**Experimental resultï¼š**

![image-20191205234830643](/Users/xuedixuedi/Library/Application Support/typora-user-images/image-20191205234830643.png)